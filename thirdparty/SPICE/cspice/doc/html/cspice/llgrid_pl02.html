
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>llgrid_pl02</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>llgrid_pl02</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void llgrid_pl02 ( SpiceInt               handle,
                      ConstSpiceDLADescr   * dladsc,
                      SpiceInt               npoints,
                      ConstSpiceDouble       grid     [][2],
                      SpiceDouble            spoints  [][3],
                      SpiceInt               plateIDs []     )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Deprecated: This routine has been superseded by the CSPICE routine
   <a href="latsrf_c.html">latsrf_c</a>. This routine is supported for purposes of backward
   compatibility only.

   Given the planetocentric longitude and latitude values of a set of
   surface points on a specified target body, compute the corresponding
   rectangular coordinates of those points.  The target body's
   surface is represented by a triangular plate model contained in a
   type 2 DSK segment.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/frames.html">FRAMES</a>
   <a href="../req/pck.html">PCK</a>
   <a href="../req/spk.html">SPK</a>
   <a href="../req/time.html">TIME</a>
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   GEOMETRY
 

 </PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   Variable  I/O  Description
   --------  ---  --------------------------------------------------
   handle     I   DSK handle.
   dlasdc     I   DLA descriptor of target body segment.
   npoints    I   Number of grid coordinate pairs.
   grid       I   Lon/lat values of surface points (radians).
   spoints    O   Rectangular coordinates of surface points.
   plateIDs   O   DSK plate IDs of surface points.
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
   handle      is the DAS file handle of a DSK file open for read
               access.  This kernel must contain a type 2 segment
               that provides a plate model representing the entire
               surface of the target body.

   dladsc      is the DLA descriptor of a DSK segment representing
               the surface of a target body.
 
   npoints     is the number of longitude/latitude pairs in the array
               of grid points `grid'.

   grid        is an array of planetocentric longitude/latitude pairs
               to be mapped to surface points on the target body.
               `grid' should be declared by the caller

                   SpiceDouble grid [npoints][2];

               Elements

                  grid[i][0]
                  grid[i][1]

               are, respectively, the planetocentric longitude and
               latitude of the ith grid point.

               Units are radians.
 </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
   spoints     is an array containing the rectangular (Cartesian)
               coordinates of the surface points on the target body,
               expressed relative to the body-fixed reference frame of
               the target body, corresponding to the input grid points.

               `spoints' should be declared by the caller

                   SpiceDouble spoints [npoints][3];

 
   plateIDs    is an array of integer ID codes of the plates on which
               the surface points are located.  The ith plate ID
               corresponds to the ith surface point. These ID codes can
               be use to look up data associated with the plate, such
               as the plate's vertices or outward normal vector.
 
               `plateIDs' should be declared by the caller

                  SpiceInt plateIDs [npoints];
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   None.
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
   If any of the listed errors occur, the output arguments are
   left unchanged.
 
 
   1) If a DSK providing a DSK type 2 plate model has not been
      loaded prior to calling <b>llgrid_pl02</b>, the error will be
      diagnosed and signaled by a routine in the call tree of this
      routine.

   2) If the segment associated with the input DLA descriptor is not
      of data type 2, the error SPICE(WRONGDATATYPE) is signaled.

   3) If a surface point cannot be computed because the ray corresponding
      to a longitude/latitude pair fails to intersect the target
      surface as defined by the plate model, the error
      SPICE(NOINTERCEPT) is signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   The following data are required:
 
      - DSK data:  a DSK file containing a plate model representing the
        target body's surface must be loaded. This kernel must contain
        a type 2 segment that contains data for the entire surface of
        the target body.
 
   In all cases, kernel data are normally loaded once per program
   run, NOT every time this routine is called.
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   See the headers of the CSPICE routines

      <a href="reclat_c.html">reclat_c</a>
      <a href="latrec_c.html">latrec_c</a>

   for detailed definitions of Planetocentric coordinates. 
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 
   The numerical results shown for this example may differ across
   platforms. The results depend on the SPICE kernels used as input,
   the compiler and supporting libraries, and the machine specific
   arithmetic implementation.
 
   In the following example program, the file

      phobos.3.3.bds

   is a DSK file containing a type 2 segment that provides a plate model 
   representation of the surface of Phobos. 

   Find the surface points on a target body corresponding to a given
   planetocentric longitude/latitude grid.  In order to duplicate
   the example output, the kernel name

      phobos.3.3.bds

   should be supplied at the prompt.


      #include &lt;stdio.h&gt;
      #include &lt;math.h&gt;
      #include &quot;SpiceUsr.h&quot;

      int main()
      {
         /.
         Local parameters
         ./
         #define  FILSIZ         256 
         #define  NAMLEN         33
         #define  NLAT           9
         #define  NLON           9 
         #define  MAXGRID        ( NLAT * NLON ) 
         #define  TOL            ( 1.e-12 )

         /.
         Local variables
         ./
         SpiceBoolean            found;

         SpiceChar               dsk      [ FILSIZ ];

         SpiceDLADescr           dladsc;

         SpiceDouble             grid     [ MAXGRID ][2];
         SpiceDouble             lat;
         SpiceDouble             lon;
         SpiceDouble             spoints  [ MAXGRID ][3];
         SpiceDouble             xlat;
         SpiceDouble             xlon;
         SpiceDouble             xr;

         SpiceInt                handle;
         SpiceInt                i;
         SpiceInt                j;
         SpiceInt                n;
         SpiceInt                npoints;
         SpiceInt                plateIDs [ MAXGRID ];



         /.
         Prompt for the name of the DSK to read and the name of
         the target body.
         ./
         <a href="prompt_c.html">prompt_c</a> ( &quot;Enter DSK name    &gt; &quot;, FILSIZ, dsk    );

         /.
         Open the DSK file for read access.
         We use the DAS-level interface for
         this function.
         ./
         <a href="dasopr_c.html">dasopr_c</a> ( dsk, &amp;handle );

         /.
         Begin a forward search through the
         kernel, treating the file as a DLA.
         In this example, it's a very short
         search.
         ./
         <a href="dlabfs_c.html">dlabfs_c</a> ( handle, &amp;dladsc, &amp;found );

         if ( !found  )
         {
            /.
            We arrive here only if the kernel
            contains no segments.  This is
            unexpected, but we're prepared for it.
            ./
            <a href="setmsg_c.html">setmsg_c</a> ( &quot;No segments found in DSK file #.&quot;);
            <a href="errch_c.html">errch_c</a>  ( &quot;#&quot;,  dsk                         );
            <a href="sigerr_c.html">sigerr_c</a> ( &quot;SPICE(NODATA)&quot;                   );
         }

         /.
         If we made it this far, DLADSC is the
         DLA descriptor of the first segment.

         Now generate the grid points.  We generate
         points along latitude bands, working from
         north to south.  The latitude range is selected
         to range from +80 to -80 degrees.  Longitude
         ranges from 0 to 350 degrees.  The increment
         is 20 degrees for latitude and 40 degrees for
         longitude.
         ./

         n = 0;

         for ( i = 0;  i &lt; NLAT;  i++  )
         {
            lat = <a href="rpd_c.html">rpd_c</a>() * ( 80.0 - 20.0*i );

            for ( j = 0;  j &lt; NLON;  j++  )
            {
               lon = <a href="rpd_c.html">rpd_c</a>() * 40.0*j;

               grid[n][0] = lon;
               grid[n][1] = lat;

               ++n;
            }
         }
         npoints = n - 1;

         /.
         Find the surface points corresponding to the grid points. 
         ./
         <b>llgrid_pl02</b> ( handle,   
                       &amp;dladsc, 
                       npoints,  
                       (ConstSpiceDouble (*)[2])grid,    
                       spoints, 
                       plateIDs                        );

         /.
         Print out the surface points in latitudinal
         coordinates and compare the derived lon/lat values
         to those of the input grid.
         ./
         for ( i = 0;  i &lt; npoints;  i++  )
         {
            /.
            Use <a href="recrad_c.html">recrad_c</a> rather than <a href="reclat_c.html">reclat_c</a> to produce
            non-negative longitudes.
            ./
            <a href="recrad_c.html">recrad_c</a> ( spoints[i], &amp;xr, &amp;xlon, &amp;xlat );

            printf ( &quot;\n&quot;
                     &quot;Intercept for grid point %d:\n&quot;
                     &quot;   Plate ID:                 %d\n&quot;
                     &quot;   Cartesian Coordinates:    (%e %e %e)\n&quot;
                     &quot;   Latitudinal Coordinates:\n&quot;
                     &quot;   Longitude (deg): %f\n&quot;
                     &quot;   Latitude  (deg): %f\n&quot;
                     &quot;   Radius     (km): %f\n&quot;
                     &quot;\n&quot;
                     &quot;Original grid coordinates:\n&quot;
                     &quot;   Longitude (deg): %f\n&quot;
                     &quot;   Latitude  (deg): %f\n&quot;
                     &quot;\n&quot;,
                     (int)i,
                     (int)plateIDs[i],
                     spoints[i][0], spoints[i][1], spoints[i][2],
                     xlon * <a href="dpr_c.html">dpr_c</a>(),
                     xlat * <a href="dpr_c.html">dpr_c</a>(),
                     xr,
                     grid[i][0] * <a href="dpr_c.html">dpr_c</a>(),
                     grid[i][1] * <a href="dpr_c.html">dpr_c</a>()                         );

            /.
            Perform sanity checks on the intercept
            coordinates.  Stop the program if any error
            is larger than our tolerance value.
            ./
            lon = grid[i][0];
            lat = grid[i][1];

            if ( fabs(xlat-lat) &gt; TOL ) 
            {
               <a href="sigerr_c.html">sigerr_c</a> ( &quot;Latitude error!&quot; );
            }

            if (  (xlon - lon)  &gt; <a href="pi_c.html">pi_c</a>()  )
            {
               xlon -= <a href="twopi_c.html">twopi_c</a>();
            }

            if (  (xlon - lon)  &gt; TOL  )
            {
               <a href="sigerr_c.html">sigerr_c</a> ( &quot;Longitude error!&quot; );
            }

         }

         /.
         Close the kernel.  This isn't necessary in a stand-
         alone program, but it's good practice in subroutines
         because it frees program and system resources.
         ./
         <a href="dascls_c.html">dascls_c</a> ( handle );

         return ( 0 );
      }


   When this program was executed on a PC/Linux/gcc platform, 
   the output for the first 3 points (the rest of the output 
   is not shown due to its large volume) was:


      Enter DSK name    &gt; phobos.3.3.bds

      Intercept for grid point 0:
         Plate ID:                 306238
         Cartesian Coordinates:    (1.520878e+00 -7.129713e-16 8.625327e+00)
         Latitudinal Coordinates:
         Longitude (deg): 360.000000
         Latitude  (deg): 80.000000
         Radius     (km): 8.758387

      Original grid coordinates:
         Longitude (deg): 0.000000
         Latitude  (deg): 80.000000


      Intercept for grid point 1:
         Plate ID:                 317112
         Cartesian Coordinates:    (1.189704e+00 9.982799e-01 8.807772e+00)
         Latitudinal Coordinates:
         Longitude (deg): 40.000000
         Latitude  (deg): 80.000000
         Radius     (km): 8.943646

      Original grid coordinates:
         Longitude (deg): 40.000000
         Latitude  (deg): 80.000000


      Intercept for grid point 2:
         Plate ID:                 324141
         Cartesian Coordinates:    (2.777752e-01 1.575341e+00 9.072029e+00)
         Latitudinal Coordinates:
         Longitude (deg): 80.000000
         Latitude  (deg): 80.000000
         Radius     (km): 9.211980

      Original grid coordinates:
         Longitude (deg): 80.000000
         Latitude  (deg): 80.000000

 
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   1) This routine assumes that the origin of the body-fixed reference 
      frame associated with the target body is located in the interior
      of that body.

   2) The results returned by this routine may not be meaningful
      if the target surface has multiple surface points associated
      with some (longitude, latitude) coordinates.
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None.
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
   N.J. Bachman   (JPL)
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 2.0.0, 23-JUL-2016 (NJB) 
 
       Added <a href="failed_c.html">failed_c</a> calls.

       Include file references have been updated. Now calls
       zzdsksgr_ instead of dsksgr_. Integer output format
       in example program has been updated.

   -Beta Version 1.3.0, 30-APR-2014 (NJB) (BVS)

       Now includes dsk_proto.h.

       Last update was 1.2.1, 07-APR-2014 (BVS)

       Changed FRAME to FRAMES in the Required_Reading section.

   -Beta Version 1.2.0, 14-MAY-2010 (NJB)

       Updated for compatibility with new DSK design.
       DSK name was updated in example program.
 
   -Beta Version 1.1.0, 09-FEB-2007 (NJB)

       Bug fix:  type of local variable fDLADescr was changed to SpiceInt.

   -Beta Version 1.0.0, 06-NOV-2006 (NJB)
 </PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   map latitudinal grid to DSK type 2 plate model surface
 </PRE>
<h4>Link to routine llgrid_pl02 source file <a href='../../../src/cspice/llgrid_pl02.c'>llgrid_pl02.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:54:38 2017</pre>

</body>
</html>


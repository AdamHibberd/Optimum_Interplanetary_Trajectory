
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>spkcov_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>spkcov_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void spkcov_c ( ConstSpiceChar  * spk,
                   SpiceInt          idcode,
                   SpiceCell       * cover   ) 

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Find the coverage window for a specified ephemeris object in a 
   specified SPK file. 
 </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/cells.html">CELLS</a> 
   <a href="../req/daf.html">DAF</a> 
   <a href="../req/spk.html">SPK</a> 
   <a href="../req/time.html">TIME</a> 
   <a href="../req/windows.html">WINDOWS</a> 
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   EPHEMERIS 
   TIME 
   UTILITY 
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   Variable  I/O  Description 
   --------  ---  -------------------------------------------------- 
   spk        I   Name of SPK file. 
   idcode     I   ID code of ephemeris object. 
   cover      O   Window giving coverage in `spk' for `idcode'. 
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
   spk            is the name of an SPK file. 
    
   idcode         is the integer ID code of an object for which 
                  ephemeris data are expected to exist in the 
                  specified SPK file. 
 
   cover          is an initialized CSPICE window data structure. 
                  `cover' optionally may contain coverage data on 
                  input; on output, the data already present in 
                  `cover' will be combined with coverage found for the 
                  object designated by `idcode' in the file `spk'. 
 
                  If `cover' contains no data on input, its size and 
                  cardinality still must be initialized. 
                   </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
   cover          is a CSPICE window data structure which 
                  represents the merged coverage for `idcode'. This is 
                  the set of time intervals for which data for 
                  `idcode' are present in the file `spk', merged with 
                  the set of time intervals present in `cover' on 
                  input.  The merged coverage is represented as the 
                  union of one or more disjoint time intervals. The 
                  window `cover' contains the pairs of endpoints of 
                  these intervals. 
 
                  The interval endpoints contained in `cover' are 
                  ephemeris times, expressed as seconds past J2000 
                  TDB. 
 
                  See the Examples section below for a complete 
                  example program showing how to retrieve the 
                  endpoints from `cover'. 
                                     </PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
   1)  If the input file has transfer format, the error  
       SPICE(INVALIDFORMAT) is signaled. 
 
   2)  If the input file is not a transfer file but has architecture 
       other than DAF, the error SPICE(BADARCHTYPE) is signaled. 
 
   3)  If the input file is a binary DAF file of type other than 
       SPK, the error SPICE(BADFILETYPE) is signaled. 
 
   4)  If the SPK file cannot be opened or read, the error will 
       be diagnosed by routines called by this routine. The output 
       window will not be modified. 
       routines called by this routine. 

   5)  If the size of the output window argument `cover' is
       insufficient to contain the actual number of intervals in the
       coverage window for `idcode', the error will be diagnosed by
       routines called by this routine.
 
   6) The error SPICE(EMPTYSTRING) is signaled if the input
      string `spk' does not contain at least one character, since the
      input string cannot be converted to a Fortran-style string in
      this case.
      
   7) The error SPICE(NULLPOINTER) is signaled if the input string
      pointer `spk' is null.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   This routine reads an SPK file.
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   This routine provides an API via which applications can determine 
   the coverage a specified SPK file provides for a specified 
   ephemeris object. 
 </PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 

   1)  Display the coverage for each object in a specified SPK file. 
       Find the set of objects in the file.  Loop over the contents 
       of the ID code set:  find the coverage for each item in the 
       set and display the coverage. 


          #include &lt;stdio.h&gt;
          #include &quot;SpiceUsr.h&quot;

          int main()
          {
             /.
             Local parameters
             ./
             #define  FILSIZ         256
             #define  MAXIV          1000
             #define  WINSIZ         ( 2 * MAXIV )
             #define  TIMLEN         51
             #define  MAXOBJ         1000

             /.
             Local variables
             ./
             SPICEDOUBLE_CELL        ( cover, WINSIZ );
             SPICEINT_CELL           ( ids,   MAXOBJ );

             SpiceChar               lsk     [ FILSIZ ];
             SpiceChar               spk     [ FILSIZ ];
             SpiceChar               timstr  [ TIMLEN ];

             SpiceDouble             b;
             SpiceDouble             e;

             SpiceInt                i;
             SpiceInt                j;
             SpiceInt                niv;
             SpiceInt                obj;


             /.
             Load a leapseconds kernel for output time conversion.
             SPKCOV itself does not require a leapseconds kernel.
             ./
             <a href="prompt_c.html">prompt_c</a> ( &quot;Name of leapseconds kernel &gt; &quot;, FILSIZ, lsk );
             <a href="furnsh_c.html">furnsh_c</a> ( lsk );

             /.
             Get name of SPK file.
             ./
             <a href="prompt_c.html">prompt_c</a> ( &quot;Name of SPK file           &gt; &quot;, FILSIZ, spk    );

             /.
             Find the set of objects in the SPK file. 
             ./
             <a href="spkobj_c.html">spkobj_c</a> ( spk, &amp;ids );

             /.
             We want to display the coverage for each object. Loop over
             the contents of the ID code set, find the coverage for
             each item in the set, and display the coverage.
             ./
             for ( i = 0;  i &lt; <a href="card_c.html">card_c</a>( &amp;ids );  i++  )
             {
                /.
                Find the coverage window for the current object. 
                Empty the coverage window each time so we don't
                include data for the previous object.
                ./
                obj  =  SPICE_CELL_ELEM_I( &amp;ids, i );

                <a href="scard_c.html">scard_c</a>  ( 0,        &amp;cover );
                <b>spkcov_c</b> ( spk, obj, &amp;cover );

                /.
                Get the number of intervals in the coverage window.
                ./
                niv = <a href="wncard_c.html">wncard_c</a> ( &amp;cover );

                /.
                Display a simple banner.
                ./
                printf ( &quot;%s\n&quot;, &quot;========================================&quot; );

                printf ( &quot;Coverage for object %d\n&quot;, (int)obj );

                /.
                Convert the coverage interval start and stop times to TDB
                calendar strings.
                ./
                for ( j = 0;  j &lt; niv;  j++  )
                {
                   /.
                   Get the endpoints of the jth interval.
                   ./
                   <a href="wnfetd_c.html">wnfetd_c</a> ( &amp;cover, j, &amp;b, &amp;e );

                   /.
                   Convert the endpoints to TDB calendar
                   format time strings and display them.
                   ./
                   <a href="timout_c.html">timout_c</a> ( b, 
                              &quot;YYYY MON DD HR:MN:SC.### (TDB) ::TDB&quot;,  
                              TIMLEN,
                              timstr                                  );

                   printf ( &quot;\n&quot;
                            &quot;Interval:  %d\n&quot;
                            &quot;Start:     %s\n&quot;,
                            (int)j,
                            timstr            );

                   <a href="timout_c.html">timout_c</a> ( e, 
                              &quot;YYYY MON DD HR:MN:SC.### (TDB) ::TDB&quot;,  
                              TIMLEN,
                              timstr                                  );
                   printf ( &quot;Stop:      %s\n&quot;, timstr );

                }

             }
             return ( 0 );
          } 
 

   2) Find the coverage for the object designated by `idcode' 
      provided by the set of SPK files loaded via a metakernel. 
      (The metakernel must also specify a leapseconds kernel.) 
        
         #include &lt;stdio.h&gt;
         #include &quot;SpiceUsr.h&quot;

         int main()
         {

            /.
            Local parameters
            ./
            #define  FILSIZ         256
            #define  LNSIZE         81 
            #define  MAXCOV         100000
            #define  WINSIZ         ( 2 * MAXCOV )
            #define  TIMLEN         51

            /.
            Local variables
            ./
            SPICEDOUBLE_CELL        ( cover, WINSIZ );

            SpiceBoolean            found;

            SpiceChar               file    [ FILSIZ ];
            SpiceChar               idch    [ LNSIZE ];
            SpiceChar               meta    [ FILSIZ ];
            SpiceChar               source  [ FILSIZ ];
            SpiceChar               timstr  [ TIMLEN ];
            SpiceChar               type    [ LNSIZE ];

            SpiceDouble             b;
            SpiceDouble             e;

            SpiceInt                count;
            SpiceInt                handle;
            SpiceInt                i;
            SpiceInt                idcode;
            SpiceInt                niv;


            /.
            Prompt for the metakernel name; load the metakernel.
            The metakernel lists the SPK files whose coverage
            for `idcode' we'd like to determine.  The metakernel
            must also specify a leapseconds kernel.
            ./
            <a href="prompt_c.html">prompt_c</a> ( &quot;Name of metakernel &gt; &quot;, FILSIZ, meta );
            <a href="furnsh_c.html">furnsh_c</a> ( meta );

            /.
            Get the ID code of interest. 
            ./
            <a href="prompt_c.html">prompt_c</a> ( &quot;Enter ID code      &gt; &quot;, LNSIZE, idch );
            <a href="prsint_c.html">prsint_c</a> ( idch,  &amp;idcode );

            /.
            Find out how many kernels are loaded.  Loop over the
            kernels:  for each loaded SPK file, add its coverage
            for `idcode', if any, to the coverage window.
            ./
            <a href="ktotal_c.html">ktotal_c</a> ( &quot;SPK&quot;, &amp;count );

            for ( i = 0;  i &lt; count;  i++  )
            {
               <a href="kdata_c.html">kdata_c</a>  ( i,     &quot;SPK&quot;,   FILSIZ,  LNSIZE,   FILSIZ, 
                          file,  type,    source,  &amp;handle,  &amp;found );

               <b>spkcov_c</b> ( file,  idcode,  &amp;cover );
            }

            /.
            Display results. 

            Get the number of intervals in the coverage window.
            ./
            niv = <a href="wncard_c.html">wncard_c</a> ( &amp;cover );

            /.
            Display a simple banner.
            ./
            printf ( &quot;\nCoverage for object %d\n&quot;, (int)idcode );

            /.
            Convert the coverage interval start and stop times to TDB
            calendar strings.
            ./
            for ( i = 0;  i &lt; niv;  i++  )
            {
               /.
               Get the endpoints of the ith interval.
               ./
               <a href="wnfetd_c.html">wnfetd_c</a> ( &amp;cover, i, &amp;b, &amp;e );

               /.
               Convert the endpoints to TDB calendar
               format time strings and display them.
               ./
               <a href="timout_c.html">timout_c</a> ( b, 
                          &quot;YYYY MON DD HR:MN:SC.### (TDB) ::TDB&quot;,  
                          TIMLEN,
                          timstr                                  );

               printf ( &quot;\n&quot;
                        &quot;Interval:  %d\n&quot;
                        &quot;Start:     %s\n&quot;,
                        (int)i,
                        timstr            );

               <a href="timout_c.html">timout_c</a> ( e, 
                          &quot;YYYY MON DD HR:MN:SC.### (TDB) ::TDB&quot;,  
                          TIMLEN,
                          timstr                                  );
               printf ( &quot;Stop:      %s\n&quot;, timstr );

            }
            return ( 0 );
         }
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   1) If an error occurs while this routine is updating the window 
      `cover', the window may be corrupted. 
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman   (JPL) 
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
   -CSPICE Version 1.0.3, 14-JUN-2016 (EDW)

       Edit to example program to use &quot;%d&quot; with explicit casts
       to int for printing SpiceInts with printf.

   -CSPICE Version 1.0.2, 01-JUL-2014 (NJB)

       Added new index entries.

   -CSPICE Version 1.0.1, 30-NOV-2007 (NJB)

       Corrected bug in first example program in header:
       program now empties result window prior to collecting
       data for each object. Deleted declaration of unused
       constant NAMLEN. Updated examples to use <a href="wncard_c.html">wncard_c</a> 
       rather than <a href="card_c.html">card_c</a>.

   -CSPICE Version 1.0.0, 30-DEC-2004 (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   get coverage window for spk_object 
   get coverage start and stop time for spk_object
   get coverage start and stop time for ephemeris_object
   get coverage start and stop time for body
 </PRE>
<h4>Link to routine spkcov_c source file <a href='../../../src/cspice/spkcov_c.c'>spkcov_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:54:43 2017</pre>

</body>
</html>


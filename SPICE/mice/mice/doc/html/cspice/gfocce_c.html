
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>gfocce_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>gfocce_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void gfocce_c ( ConstSpiceChar     * occtyp,
                   ConstSpiceChar     * front,
                   ConstSpiceChar     * fshape,
                   ConstSpiceChar     * fframe,
                   ConstSpiceChar     * back,
                   ConstSpiceChar     * bshape,
                   ConstSpiceChar     * bframe,
                   ConstSpiceChar     * abcorr,
                   ConstSpiceChar     * obsrvr,
                   SpiceDouble          tol,

                   void             ( * udstep ) ( SpiceDouble       et,
                                                   SpiceDouble     * step ),

                   void             ( * udrefn ) ( SpiceDouble       t1,
                                                   SpiceDouble       t2,
                                                   SpiceBoolean      s1,
                                                   SpiceBoolean      s2,
                                                   SpiceDouble     * t    ),
                   SpiceBoolean         rpt,  

                   void             ( * udrepi ) ( SpiceCell       * cnfine,
                                                   ConstSpiceChar  * srcpre,
                                                   ConstSpiceChar  * srcsuf ),

                   void             ( * udrepu ) ( SpiceDouble       ivbeg,
                                                   SpiceDouble       ivend,
                                                   SpiceDouble       et      ),

                   void             ( * udrepf ) ( void ),
                   SpiceBoolean         bail,      
                   SpiceBoolean     ( * udbail ) ( void ),
                   SpiceCell          * cnfine,
                   SpiceCell          * result                                )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Determine time intervals when an observer sees one target 
   occulted by another. Report progress and handle interrupts 
   if so commanded. 
 
   The surfaces of the target bodies may be represented by triaxial
   ellipsoids or by topographic data provided by DSK files.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/frames.html">FRAMES</a> 
   <a href="../req/gf.html">GF</a> 
   <a href="../req/kernel.html">KERNEL</a> 
   <a href="../req/naif_ids.html">NAIF_IDS</a> 
   <a href="../req/spk.html">SPK</a> 
   <a href="../req/time.html">TIME</a> 
   <a href="../req/windows.html">WINDOWS</a>   
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   EVENT 
   GEOMETRY 
   SEARCH 
   WINDOW 
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   VARIABLE  I/O  DESCRIPTION 
   --------  ---  -------------------------------------------------- 
   occtyp     I   Type of occultation. 
   front      I   Name of body occulting the other. 
   fshape     I   Type of shape model used for front body. 
   fframe     I   Body-fixed, body-centered frame for front body. 
   back       I   Name of body occulted by the other. 
   bshape     I   Type of shape model used for back body. 
   bframe     I   Body-fixed, body-centered frame for back body. 
   abcorr     I   Aberration correction flag. 
   obsrvr     I   Name of the observing body. 
   tol        I   Convergence tolerance in seconds. 
   udstep     I   Name of the routine that returns a time step. 
   udrefn     I   Name of the routine that computes a refined time. 
   rpt        I   Progress report flag. 
   udrepi     I   Function that initializes progress reporting. 
   udrepu     I   Function that updates the progress report. 
   udrepf     I   Function that finalizes progress reporting. 
   bail       I   Logical indicating program interrupt monitoring. 
   udbail     I   Name of a routine that signals a program interrupt. 
   cnfine    I-O  SPICE window to which the search is restricted. 
   result     O   SPICE window containing results. 
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
 
   occtyp     indicates the type of occultation that is to be found. 
              Supported values and corresponding definitions are: 
 
                 &quot;FULL&quot;               denotes the full occultation 
                                      of the body designated by  
                                      `back' by the body designated 
                                      by `front', as seen from 
                                      the location of the observer. 
                                      In other words, the occulted 
                                      body is completely invisible 
                                      as seen from the observer's 
                                      location. 
 
                 &quot;ANNULAR&quot;            denotes an annular 
                                      occultation: the body 
                                      designated by `front' blocks 
                                      part of, but not the limb of, 
                                      the body designated by `back', 
                                      as seen from the location of 
                                      the observer. 
 
                 &quot;PARTIAL&quot;            denotes an partial, 
                                      non-annular occultation: the 
                                      body designated by `front' 
                                      blocks part, but not all, of 
                                      the limb of the body 
                                      designated by `back', as seen 
                                      from the location of the 
                                      observer. 
 
                 &quot;ANY&quot;                denotes any of the above three 
                                      types of occultations: 
                                      &quot;PARTIAL&quot;, &quot;ANNULAR&quot;, or 
                                      &quot;FULL&quot;. 
 
                                      &quot;ANY&quot; should be used to search 
                                      for times when the body  
                                      designated by `front' blocks 
                                      any part of the body designated 
                                      by `back'. 
 
                                      The option &quot;ANY&quot; must be used 
                                      if either the front or back 
                                      target body is modeled as 
                                      a point. 
 
              Case and leading or trailing blanks are not 
              significant in the string `occtyp'. 
 
 
   front      is the name of the target body that occults---that is, 
              passes in front of---the other. Optionally, you may 
              supply the integer NAIF ID code for the body as a 
              string. For example both &quot;MOON&quot; and &quot;301&quot; are 
              legitimate strings that designate the Moon. 
 
              Case and leading or trailing blanks are not 
              significant in the string `front'. 
 
 
   fshape     is a string indicating the geometric model used to
              represent the shape of the front target body. The
              supported options are:
 
                 &quot;ELLIPSOID&quot;     Use a triaxial ellipsoid model
                                 with radius values provided via the 
                                 kernel pool. A kernel variable  
                                 having a name of the form 
 
                                    &quot;BODYnnn_RADII&quot;  
 
                                 where nnn represents the NAIF 
                                 integer code associated with the 
                                 body, must be present in the kernel 
                                 pool. This variable must be 
                                 associated with three numeric 
                                 values giving the lengths of the 
                                 ellipsoid's X, Y, and Z semi-axes. 
 
                 &quot;POINT&quot;         Treat the body as a single point. 
                                 When a point target is specified, 
                                 the occultation type must be 
                                 set to &quot;ANY&quot;. 
                                   
              
                 &quot;DSK/UNPRIORITIZED[/SURFACES = &lt;surface list&gt;]&quot;

                     Use topographic data provided by DSK files to
                     model the body's shape. These data must be
                     provided by loaded DSK files.

                     The surface list specification is optional. The
                     syntax of the list is

                        &lt;surface 1&gt; [, &lt;surface 2&gt;...]

                     If present, it indicates that data only for the
                     listed surfaces are to be used; however, data
                     need not be available for all surfaces in the
                     list. If absent, loaded DSK data for any surface
                     associated with the target body are used.

                     The surface list may contain surface names or
                     surface ID codes. Names containing blanks must
                     be delimited by double quotes, for example

                        SURFACES = &quot;Mars MEGDR 128 PIXEL/DEG&quot;

                     If multiple surfaces are specified, their names
                     or IDs must be separated by commas.

                     See the Particulars section below for details
                     concerning use of DSK data.

              The combinations of the shapes of the target bodies
              `front' and `back' must be one of:

                 One ELLIPSOID, one POINT
                 Two ELLIPSOIDs
                 One DSK, one POINT 

              Case and leading or trailing blanks are not 
              significant in the string `fshape'. 
 
 
   fframe     is the name of the body-fixed, body-centered reference 
              frame associated with the front target body. Examples 
              of such names are &quot;IAU_SATURN&quot; (for Saturn) and 
              &quot;ITRF93&quot; (for the Earth). 
 
              If the front target body is modeled as a point, `fframe' 
              should be left empty or blank. 
 
              Case and leading or trailing blanks bracketing a
              non-blank frame name are not significant in the string
              `fframe'.

 
   back       is the name of the target body that is occulted 
              by---that is, passes in back of---the other. 
              Optionally, you may supply the integer NAIF ID code 
              for the body as a string. For example both &quot;MOON&quot; and 
              &quot;301&quot; are legitimate strings that designate the Moon. 
 
              Case and leading or trailing blanks are not 
              significant in the string `back'. 
 
 
   bshape     is the shape specification for the body designated 
              by `back'. See the description of `fshape' above for 
              details. 
               
 
   bframe     is the name of the body-fixed, body-centered reference 
              frame associated with the ``back'' target body. 
              Examples of such names are &quot;IAU_SATURN&quot; (for Saturn) 
              and &quot;ITRF93&quot; (for the Earth). 
 
              If the back target body is modeled as a point, `bframe' 
              should be left empty or blank. 
 
              Case and leading or trailing blanks bracketing a 
              non-blank frame name are not significant in the string 
              `bframe'. 
  
 
   abcorr     indicates the aberration corrections to be applied to 
              the state of the target body to account for one-way 
              light time.  Stellar aberration corrections are 
              ignored if specified, since these corrections don't 
              improve the accuracy of the occultation determination. 
 
              See the header of the SPICE routine <a href="spkezr_c.html">spkezr_c</a> for a 
              detailed description of the aberration correction 
              options. For convenience, the options supported by 
              this routine are listed below: 
 
                 &quot;NONE&quot;     Apply no correction.    
 
                 &quot;LT&quot;       &quot;Reception&quot; case:  correct for 
                            one-way light time using a Newtonian 
                            formulation. 
 
                 &quot;CN&quot;       &quot;Reception&quot; case:  converged 
                            Newtonian light time correction. 
 
                 &quot;XLT&quot;      &quot;Transmission&quot; case:  correct for 
                            one-way light time using a Newtonian 
                            formulation. 
 
                 &quot;XCN&quot;      &quot;Transmission&quot; case:  converged 
                            Newtonian light time correction. 
 
              Case and blanks are not significant in the string 
              `abcorr'. 
 
 
   obsrvr     is the name of the body from which the occultation is 
              observed. Optionally, you may supply the integer NAIF 
              ID code for the body as a string. 
 
              Case and leading or trailing blanks are not 
              significant in the string `obsrvr'. 

  
   tol        is a tolerance value used to determine convergence of 
              root-finding operations. `tol' is measured in TDB seconds 
              and must be greater than zero. 
 
 
   udstep     is an externally specified routine that computes a 
              time step in an attempt to find a transition of the 
              state being considered. In the context of this 
              routine's algorithm, a &quot;state transition&quot; occurs where 
              the state changes from being &quot;in occultation&quot; to being 
              &quot;not in occultation&quot; or vice versa. 
          
              This routine relies on `udstep' returning step sizes 
              small enough so that state transitions within the 
              confinement window are not overlooked.  There must 
              never be two roots A and B separated by less than 
              `step', where `step' is the minimum step size returned by 
              `udstep' for any value of `et'; in the interval [A, B]. 
  
              The prototype for `udstep' is
 
                 void   ( * udstep ) ( SpiceDouble       et,
                                       SpiceDouble     * step )

              where: 
 
                 et      is the input start time from which the 
                         algorithm is to search forward for a state 
                         transition. `et' is expressed as seconds past 
                         J2000 TDB.  
 
                 step    is the output step size.  `step' indicates 
                         how far to advance `et' so that `et' and 
                         et+step may bracket a state transition and 
                         definitely do not bracket more than one 
                         state transition. Units are TDB seconds. 
 
              If a constant step size is desired, the CSPICE routine 

                 <a href="gfstep_c.html">gfstep_c</a> 
 
              may be used as the step size function. If <a href="gfstep_c.html">gfstep_c</a> is
              used, the step size must be set by calling <a href="gfsstp_c.html">gfsstp_c</a> prior
              to calling this routine.
 
 
   udrefn     is the name of the externally specified routine that 
              computes a refinement in the times that bracket a 
              transition point. In other words, once a pair of 
              times have been detected such that the system is in 
              different states at each of the two times, `udrefn' 
              selects an intermediate time which should be closer to 
              the transition state than one of the two known times. 
              The prototype for `udrefn' is: 
 
                 void   ( * udrefn ) ( SpiceDouble       t1,
                                       SpiceDouble       t2,
                                       SpiceBoolean      s1,
                                       SpiceBoolean      s2,
                                       SpiceDouble     * t   )
 
              where the inputs are: 
 
                 t1    is a time when the system is in state `s1'. `t1'
                       is expressed as seconds past J2000 TDB.
 
                 t2    is a time when the system is in state `s2'. `t2'
                       is expressed as seconds past J2000 TDB. `t2' is
                       assumed to be larger than `t1'.
 
                 s1    is the state of the system at time t1.

                 s2    is the state of the system at time t2.
  
              The output is: 
 
                 t     is next time to check for a state transition.
                       `t' is a number between `t1' and `t2'. `t' is
                       expressed as seconds past J2000 TDB.
 
              If a simple bisection method is desired, the CSPICE routine 
              <a href="gfrefn_c.html">gfrefn_c</a> may be used as the refinement function.
 
 
   rpt        is a logical variable which controls whether 
              progress reporting is enabled. When `rpt' is SPICETRUE, 
              progress reporting is enabled and the routines 
              udrepi, udrepu, and udpref (see descriptions below) 
              are used to report progress.  
  
 
   udrepi     is a user-defined subroutine that initializes a 
              progress report.  When progress reporting is  
              enabled, `udrepi' is called at the start 
              of a search. The prototype for `udrefi' is

                 void   ( * udrepi ) ( SpiceCell       * cnfine,
                                       ConstSpiceChar  * srcpre,
                                       ConstSpiceChar  * srcsuf )
 
              where 
 
                 cnfine  
 
              is a confinement window specifying the time period
              over which a search is conducted, and
  
                 srcpre 
                 srcsuf 
 
              are prefix and suffix strings used in the progress 
              report: these strings are intended to bracket a  
              representation of the fraction of work done. For
              example, when the CSPICE progress reporting functions
              are used, if srcpre and srcsuf are, respectively,

                 &quot;Occultation/transit search&quot;
                 &quot;done.&quot;
 
              the progress report display at the end of
              the search will be:

                 Occultation/transit search 100.00% done.

              The CSPICE routine <a href="gfrepi_c.html">gfrepi_c</a> may be used as the
              actual argument corresponding to `udrepi'. If so,
              the CSPICE routines <a href="gfrepu_c.html">gfrepu_c</a> and <a href="gfrepf_c.html">gfrepf_c</a> must be
              the actual arguments corresponding to `udrepu' and
              `udrepf'.
             
 
   udrepu     is a user-defined subroutine that updates the  
              progress report for a search.  The prototype
              of `udrepu' is 
  
                 void   ( * udrepu ) ( SpiceDouble       ivbeg,
                                       SpiceDouble       ivend,
                                       SpiceDouble       et      )
 
              In order for a meaningful progress report to be displayed,
              `ivbeg' and `ivend' must satisfy the following constraints:

                 - `ivbeg' must be less than or equal to `ivend'. 

                 - Over a search, the sum of the differences 

                      ivend - ivbeg

                   for all calls to this routine made during the search
                   must equal the measure (that is, the sum of the 
                   lengths of the intervals) of the confinement window
                   `cnfine'.

              `et' is the current time reached in the search for an event. 
              `et' must lie in the interval  

                 ivbeg : ivend 

              inclusive. The input values of `et' for a given interval 
              need not form an increasing sequence.  

              The CSPICE routine <a href="gfrepu_c.html">gfrepu_c</a> may be used as the actual
              argument corresponding to `udrepu'. If so, the CSPICE
              routines <a href="gfrepi_c.html">gfrepi_c</a> and <a href="gfrepf_c.html">gfrepf_c</a> must be the actual
              arguments corresponding to `udrepi' and `udrepf'.
 
 
   udrepf     is a user-defined subroutine that finalizes a progress
              report. `udrepf' has no arguments.
 
              The CSPICE routine <a href="gfrepf_c.html">gfrepf_c</a> may be used as the actual
              argument corresponding to `udrepf'. If so, the CSPICE
              routines <a href="gfrepi_c.html">gfrepi_c</a> and <a href="gfrepu_c.html">gfrepu_c</a> must be the actual
              arguments corresponding to `udrepi' and `udrepu'.
 
 
   bail       is a logical variable indicating whether or not 
              interrupt handling is enabled. When `bail' is 
              set to SPICETRUE, the input function `udbail' (see 
              description below) is used to determine whether 
              an interrupt has been issued. 
 
 
   udbail     is the name of a user defined logical function that 
              indicates whether an interrupt signal has been  
              issued (for example, from the keyboard). udbail
              has the prototype

                 SpiceBoolean   ( * udbail ) ( void )

              The return value is SPICETRUE if an interrupt has 
              been issued; otherwise the value is SPICEFALSE.

              <b>gfocce_c</b> uses `udbail' only when `bail' (see above) is set 
              to SPICETRUE, indicating that interrupt handling is 
              enabled. When interrupt handling is enabled, <b>gfocce_c</b> 
              and routines in its call tree will call `udbail' to 
              determine whether to terminate processing and return 
              immediately.                

              If the user doesn't wish to provide a custom interrupt
              handling function, the CSPICE routine

                 <a href="gfbail_c.html">gfbail_c</a>

              may be used.   

              The function `udbail' will be usually be tested
              multiple times by the GF system between the time
              an interrupt is issued and the time when 
              control is returned to the calling program, so
              `udbail' nmust continue to return SPICETRUE
              until explicitly reset by the calling application.
              So `udbail' must provide a &quot;reset&quot; mechanism.&quot;
              In the case of <a href="gfbail_c.html">gfbail_c</a>, the reset function is
              
                 <a href="gfclrh_c.html">gfclrh_c</a>              

              If interrupt handing is not enabled, a logical 
              function must still be passed to <b>gfocce_c</b> as 
              an input argument. The CSPICE function  
 
                 <a href="gfbail_c.html">gfbail_c</a> 
       
              may be used for this purpose. 
 
              See the Examples header section below for a complete code
              example demonstrating use of the CSPICE interrupt
              handling capability.


   cnfine     is a SPICE window that confines the time period over 
              which the specified search is conducted. `cnfine' may 
              consist of a single interval or a collection of  
              intervals.  
  
              The endpoints of the time intervals comprising `cnfine'
              are interpreted as seconds past J2000 TDB.
               
              See the Examples section below for a code example  
              that shows how to create a confinement window. 

      </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
   cnfine     is the input confinement window, updated if necessary
              so the control area of its data array indicates the
              window's size and cardinality. The window data are
              unchanged.


   result     is a SPICE window representing the set of time 
              intervals, within the confinement period, when the 
              specified occultation occurs. 
 
              The endpoints of the time intervals comprising `result'
              are interpreted as seconds past J2000 TDB.

              If `result' is non-empty on input, its contents 
              will be discarded before <b>gfocce_c</b> conducts its 
              search. 
 </PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   None.
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
 
   1)  In order for this routine to produce correct results, 
       the step size must be appropriate for the problem at hand. 
       Step sizes that are too large may cause this routine to miss 
       roots; step sizes that are too small may cause this routine 
       to run unacceptably slowly and in some cases, find spurious 
       roots. 
 
       This routine does not diagnose invalid step sizes, except 
       that if the step size is non-positive, the error  
       SPICE(INVALIDSTEPSIZE) will be signaled. 
 
   2)  Due to numerical errors, in particular, 
 
          - Truncation error in time values 
          - Finite tolerance value 
          - Errors in computed geometric quantities 
 
       it is *normal* for the condition of interest to not always be 
       satisfied near the endpoints of the intervals comprising the 
       result window. 
 
       The result window may need to be contracted slightly by the 
       caller to achieve desired results. The SPICE window routine 
       <a href="wncond_c.html">wncond_c</a> can be used to contract the result window. 
 
   3)  If name of either target or the observer cannot be translated 
       to a NAIF ID code, the error will be diagnosed by a routine 
       in the call tree of this routine. 
        
   4)  If the radii of a target body modeled as an ellipsoid cannot 
       be determined by searching the kernel pool for a kernel 
       variable having a name of the form 
 
          &quot;BODYnnn_RADII&quot;  
 
       where nnn represents the NAIF integer code associated with 
       the body, the error will be diagnosed by a routine in the 
       call tree of this routine. 
 
   5)  If either of the target bodies `front' or `back' coincides with 
       the observer body `obsrvr', the error will be diagnosed by a 
       routine in the call tree of this routine. 
 
   6)  If the body designated by `front' coincides with that 
       designated by `back', the error will be diagnosed by a routine 
       in the call tree of this routine. 
        
   7)  If either of the body model specifiers `fshape' or `bshape' 
       is not recognized, the error will be diagnosed by a routine 
       in the call tree of this routine. 
 
   8)  If both of the body model specifiers `fshape' and `bshape' 
       specify point targets, the error will be diagnosed by a 
       routine in the call tree of this routine. 
 
   9)  If a target body-fixed reference frame associated with a  
       non-point target is not recognized, the error will be 
       diagnosed by a routine in the call tree of this routine. 
 
   10) If a target body-fixed reference frame is not centered at 
       the corresponding target body,  the error will be 
       diagnosed by a routine in the call tree of this routine. 
 
   11) If the loaded kernels provide insufficient data to  
       compute the requested state vector, the deficiency will 
       be diagnosed by a routine in the call tree of this routine. 
 
   12) If an error occurs while reading an SPK or other kernel file, 
       the error will be diagnosed by a routine in the call tree  
       of this routine. 
 
   13) If the output SPICE window `result' has insufficient capacity 
       to contain the number of intervals on which the specified 
       occultation condition is met, the error will be diagnosed 
       by a routine in the call tree of this routine. 
 
   14) If a point target is specified and the occultation 
       type is set to a valid value other than &quot;ANY&quot;, the 
       error will be diagnosed by a routine in the call tree  
       of this routine. 

   15) Invalid aberration correction specifications will be
       diagnosed by a routine in the call tree of this routine.

   16) If either `fshape' or `bshape' specifies that the target surface
       is represented by DSK data, and no DSK files are loaded for
       the specified target, the error is signaled by a routine in
       the call tree of this routine.

   17) If either `fshape' or `bshape' specifies that the target surface
       is represented by DSK data, but the shape specification is
       invalid, the error is signaled by a routine in the call tree
       of this routine.

   18) If any input string argument pointer is null, the error
       SPICE(NULLPOINTER) will be signaled.

   19) If any input string argument, other than `fframe' or `bframe',
       is empty, the error SPICE(EMPTYSTRING) will be signaled.

   20) If the convergence tolerance size is non-positive, the error 
       SPICE(INVALIDTOLERANCE) will be signaled. 
  
   21) If the occultation type is not recognized, the error 
       SPICE(INVALIDOCCTYPE) is signaled.

   22) If any attempt to change the handler for the interrupt 
       signal SIGINT fails, the error SPICE(SIGNALFAILURE) is
       signaled.

   23) If operation of this routine is interrupted, the output result
       window will be invalid.
 
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   
   Appropriate SPICE kernels must be loaded by the calling program
   before this routine is called.

   The following data are required:

      - SPK data: the calling application must load ephemeris data
        for the targets, source and observer that cover the time
        period specified by the window `cnfine'. If aberration
        corrections are used, the states of the target bodies and of
        the observer relative to the solar system barycenter must be
        calculable from the available ephemeris data. Typically
        ephemeris data are made available by loading one or more SPK
        files via <a href="furnsh_c.html">furnsh_c</a>.

      - PCK data: bodies modeled as triaxial ellipsoids must have
        semi-axis lengths provided by variables in the kernel pool.
        Typically these data are made available by loading a text
        PCK file via <a href="furnsh_c.html">furnsh_c</a>.

      - FK data: if either of the reference frames designated by
        `bframe' or `fframe' are not built in to the SPICE system,
        one or more FKs specifying these frames must be loaded.

   The following data may be required:

      - DSK data: if either `fshape' or `bshape' indicates that DSK
        data are to be used, DSK files containing topographic data
        for the target body must be loaded. If a surface list is
        specified, data for at least one of the listed surfaces must
        be loaded.

      - Surface name-ID associations: if surface names are specified
        in `fshape' or `bshape', the association of these names with
        their corresponding surface ID codes must be established by
        assignments of the kernel variables

           NAIF_SURFACE_NAME
           NAIF_SURFACE_CODE
           NAIF_SURFACE_BODY

        Normally these associations are made by loading a text
        kernel containing the necessary assignments. An example
        of such a set of assignments is

           NAIF_SURFACE_NAME += 'Mars MEGDR 128 PIXEL/DEG'
           NAIF_SURFACE_CODE += 1
           NAIF_SURFACE_BODY += 499

      - CK data: either of the body-fixed frames to which `fframe' or
        `bframe' refer might be a CK frame. If so, at least one CK
        file will be needed to permit transformation of vectors
        between that frame and the J2000 frame.

      - SCLK data: if a CK file is needed, an associated SCLK
        kernel is required to enable conversion between encoded SCLK
        (used to time-tag CK data) and barycentric dynamical time
        (TDB).

   Kernel data are normally loaded once per program run, NOT every
   time this routine is called.

 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   This routine provides the SPICE GF system's most flexible 
   interface for searching for occultation events. 
  
   Applications that require do not require support for progress 
   reporting, interrupt handling, non-default step or refinement 
   functions, or non-default convergence tolerance normally should 
   call <a href="gfoclt_c.html">gfoclt_c</a> rather than this routine. 
 
   This routine determines a set of one or more time intervals 
   within the confinement window when a specified type of 
   occultation occurs. The resulting set of intervals is returned as 
   a SPICE window. 
 
   Below we discuss in greater detail aspects of this routine's 
   solution process that are relevant to correct and efficient 
   use of this routine in user applications. 
    
 
   The Search Process 
   ================== 
 
   The search for occultations is treated as a search for state 
   transitions: times are sought when the state of the BACK body 
   changes from &quot;not occulted&quot; to &quot;occulted&quot; or vice versa. 
 
   Step Size 
   ========= 
 
   Each interval of the confinement window is searched as follows: 
   first, the input step size is used to determine the time 
   separation at which the occultation state will be sampled. 
   Starting at the left endpoint of an interval, samples will be 
   taken at each step. If a state change is detected, a root has 
   been bracketed; at that point, the &quot;root&quot;--the time at which the 
   state change occurs---is found by a refinement process, for 
   example, via binary search. 
 
   Note that the optimal choice of step size depends on the lengths 
   of the intervals over which the occultation state is constant: 
   the step size should be shorter than the shortest occultation 
   duration and the shortest period between occultations, within 
   the confinement window. 
 
   Having some knowledge of the relative geometry of the targets and 
   observer can be a valuable aid in picking a reasonable step size. 
   In general, the user can compensate for lack of such knowledge by 
   picking a very short step size; the cost is increased computation 
   time. 
 
   Note that the step size is not related to the precision with which 
   the endpoints of the intervals of the result window are computed. 
   That precision level is controlled by the convergence tolerance. 
 
 
   Convergence Tolerance 
   ===================== 
 
   Once a root has been bracketed, a refinement process is used to
   narrow down the time interval within which the root must lie. This
   refinement process terminates when the location of the root has been
   determined to within an error margin called the &quot;convergence
   tolerance.&quot; The convergence tolerance used by high-level GF routines
   that call this routine is set via the parameter SPICE_GF_CNVTOL,
   which is declared in the header file SpiceGF.h.
  
   The value of SPICE_GF_CNVTOL is set to a &quot;tight&quot; value so that the 
   tolerance doesn't become the limiting factor in the accuracy of 
   solutions found by this routine. In general the accuracy of input 
   data will be the limiting factor. 
 
   Making the tolerance tighter than SPICE_GF_CNVTOL is unlikely to be
   useful, since the results are unlikely to be more accurate. Making
   the tolerance looser will speed up searches somewhat, since a few
   convergence steps will be omitted. However, in most cases, the step
   size is likely to have a much greater affect on processing time than
   would the convergence tolerance.
 
 
   The Confinement Window 
   ====================== 
 
   The simplest use of the confinement window is to specify a time
   interval within which a solution is sought. However, the confinement
   window can, in some cases, be used to make searches more efficient.
   Sometimes it's possible to do an efficient search to reduce the size
   of the time period over which a relatively slow search of interest
   must be performed. For an example, see the program CASCADE in the GF
   Example Programs chapter of the GF Required Reading, gf.req.
 
 
   Using DSK data 
   ============== 
 
      DSK loading and unloading 
      ------------------------- 
 
      DSK files providing data used by this routine are loaded by 
      calling <a href="furnsh_c.html">furnsh_c</a> and can be unloaded by calling <a href="unload_c.html">unload_c</a> or 
      <a href="kclear_c.html">kclear_c</a>. See the documentation of <a href="furnsh_c.html">furnsh_c</a> for limits on numbers 
      of loaded DSK files. 
 
      For run-time efficiency, it's desirable to avoid frequent 
      loading and unloading of DSK files. When there is a reason to 
      use multiple versions of data for a given target body---for 
      example, if topographic data at varying resolutions are to be 
      used---the surface list can be used to select DSK data to be 
      used for a given computation. It is not necessary to unload 
      the data that are not to be used. This recommendation presumes 
      that DSKs containing different versions of surface data for a 
      given body have different surface ID codes. 
 
 
      DSK data priority 
      ----------------- 
 
      A DSK coverage overlap occurs when two segments in loaded DSK 
      files cover part or all of the same domain---for example, a 
      given longitude-latitude rectangle---and when the time 
      intervals of the segments overlap as well. 
 
      When DSK data selection is prioritized, in case of a coverage 
      overlap, if the two competing segments are in different DSK 
      files, the segment in the DSK file loaded last takes 
      precedence. If the two segments are in the same file, the 
      segment located closer to the end of the file takes 
      precedence. 
 
      When DSK data selection is unprioritized, data from competing 
      segments are combined. For example, if two competing segments 
      both represent a surface as a set of triangular plates, the 
      union of those sets of plates is considered to represent the 
      surface.  
 
      Currently only unprioritized data selection is supported. 
      Because prioritized data selection may be the default behavior 
      in a later version of the routine, the UNPRIORITIZED keyword is 
      required in the `fshape' and `bshape' arguments. 
 
       
      Syntax of the shape input arguments for the DSK case
      ----------------------------------------------------
 
      The keywords and surface list in the target shape arguments
      `bshape' and `fshape' are called &quot;clauses.&quot; The clauses may
      appear in any order, for example
 
         &quot;DSK/&lt;surface list&gt;/UNPRIORITIZED&quot;
         &quot;DSK/UNPRIORITIZED/&lt;surface list&gt;&quot;
         &quot;UNPRIORITIZED/&lt;surface list&gt;/DSK&quot;
 
      The simplest form of the `method' argument specifying use of 
      DSK data is one that lacks a surface list, for example: 
 
         &quot;DSK/UNPRIORITIZED&quot; 
 
      For applications in which all loaded DSK data for the target 
      body are for a single surface, and there are no competing 
      segments, the above string suffices. This is expected to be 
      the usual case. 
 
      When, for the specified target body, there are loaded DSK 
      files providing data for multiple surfaces for that body, the 
      surfaces to be used by this routine for a given call must be 
      specified in a surface list, unless data from all of the 
      surfaces are to be used together. 
 
      The surface list consists of the string 
 
         &quot;SURFACES = &quot;
 
      followed by a comma-separated list of one or more surface 
      identifiers. The identifiers may be names or integer codes in 
      string format. For example, suppose we have the surface 
      names and corresponding ID codes shown below: 
 
         Surface Name                              ID code 
         ------------                              ------- 
         &quot;Mars MEGDR 128 PIXEL/DEG&quot;                1 
         &quot;Mars MEGDR 64 PIXEL/DEG&quot;                 2 
         &quot;Mars_MRO_HIRISE&quot;                         3 
 
      If data for all of the above surfaces are loaded, then 
      data for surface 1 can be specified by either 
 
         &quot;SURFACES = 1&quot; 
 
      or 
 
         &quot;SURFACES = \&quot;Mars MEGDR 128 PIXEL/DEG\&quot;&quot; 
 
      Escaped double quotes are used to delimit the surface name because 
      it contains blank characters.  
          
      To use data for surfaces 2 and 3 together, any 
      of the following surface lists could be used: 
 
         &quot;SURFACES = 2, 3&quot; 
 
         &quot;SURFACES = \&quot;Mars MEGDR  64 PIXEL/DEG\&quot;, 3&quot; 
 
         &quot;SURFACES = 2, Mars_MRO_HIRISE&quot; 
 
         &quot;SURFACES = \&quot;Mars MEGDR 64 PIXEL/DEG\&quot;, Mars_MRO_HIRISE&quot; 
        
      An example of a shape argument that could be constructed 
      using one of the surface lists above is 
 
         &quot;DSK/UNPRIORITIZED/SURFACES = \&quot;Mars MEGDR 64 PIXEL/DEG\&quot;, 3&quot; 
  
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 
 
   The numerical results shown for these examples may differ across
   platforms. The results depend on the SPICE kernels used as
   input, the compiler and supporting libraries, and the machine
   specific arithmetic implementation.


   1) Conduct a search using default GF progress reporting 
      and interrupt handling capabilities. 

      The program will use console I/O to display a simple
      ASCII-based progress report. 

      The program will trap keyboard interrupts (on most systems,
      generated by typing the &quot;control C&quot; key combination). This
      feature can be used in non-trivial applications to allow
      the application to continue after a search as been interrupted.
 
      The program will find occultations of the Sun by the Moon as seen
      from the center of the Earth over the month December, 2001.

      Use light time corrections to model apparent positions of Sun
      and Moon. Stellar aberration corrections are not specified
      because they don't affect occultation computations.
 
      We select a step size of 20 seconds, which implies we ignore
      occultation events lasting less than 20 seconds, if any exist.
      Given this step size and the length of the search interval, the
      user has time to interrupt the computation. In an interactive
      setting, the user might speed up the search by lengthening the
      step size or shortening the search interval, as long as these
      adjustments don't prevent the search from finding the correct
      solution.
 
      Use the meta-kernel shown below to load the required SPICE
      kernels.

         KPL/MK

         File name: standard.tm

         This meta-kernel is intended to support operation of SPICE
         example programs. The kernels shown here should not be
         assumed to contain adequate or correct versions of data
         required by SPICE-based user applications.

         In order for an application to use this meta-kernel, the
         kernels referenced here must be present in the user's
         current working directory.


         \begindata

            KERNELS_TO_LOAD = ( 'de421.bsp',
                                'pck00008.tpc',
                                'naif0009.tls'  )

         \begintext
 

      Example code begins here.


         #include &quot;SpiceUsr.h&quot;
         #include &lt;stdio.h&gt;

         int main()
         {
            /.
            Constants 
            ./
            #define  TIMFMT  &quot;YYYY MON DD HR:MN:SC.###### ::TDB (TDB)&quot;
            #define  CNVTOL  1.e-6
            #define  MAXWIN  200
            #define  TIMLEN  41

            /.
            Local variables 
            ./
            SpiceBoolean            bail;
            SpiceBoolean            rpt;

            SpiceChar             * win0;
            SpiceChar             * win1;
            SpiceChar               begstr [ TIMLEN ];
            SpiceChar               endstr [ TIMLEN ];

            SPICEDOUBLE_CELL      ( cnfine, MAXWIN );
            SPICEDOUBLE_CELL      ( result, MAXWIN );

            SpiceDouble             et0;
            SpiceDouble             et1;
            SpiceDouble             left;
            SpiceDouble             right;

            SpiceInt                i;

            /.
            Load kernels.
            ./
            <a href="furnsh_c.html">furnsh_c</a> ( &quot;standard.tm&quot; );

            /.
            Obtain the TDB time bounds of the confinement
            window, which is a single interval in this case.
            ./
            win0 = &quot;2001 DEC 10 00:00:00 TDB&quot;;
            win1 = &quot;2002 JAN 01 00:00:00 TDB&quot;;

            <a href="str2et_c.html">str2et_c</a> ( win0, &amp;et0 );
            <a href="str2et_c.html">str2et_c</a> ( win1, &amp;et1 );

            /.
            Insert the time bounds into the confinement
            window.
            ./
            <a href="wninsd_c.html">wninsd_c</a> ( et0, et1, &amp;cnfine );

            /.
            Select a twenty-second step. We'll ignore any occultations
            lasting less than 20 seconds.
            ./
            <a href="gfsstp_c.html">gfsstp_c</a> ( 20.0 );

            /.
            Turn on interrupt handling and progress reporting.
            ./
            bail = SPICETRUE;
            rpt  = SPICETRUE;

            /.
            Perform the search.
            ./
            <b>gfocce_c</b> ( &quot;ANY&quot;,                            
                       &quot;MOON&quot;,     &quot;ellipsoid&quot;,  &quot;IAU_MOON&quot;, 
                       &quot;SUN&quot;,      &quot;ellipsoid&quot;,  &quot;IAU_SUN&quot;,  
                       &quot;LT&quot;,       &quot;EARTH&quot;,      CNVTOL,    
                       <a href="gfstep_c.html">gfstep_c</a>,   <a href="gfrefn_c.html">gfrefn_c</a>,     rpt,       
                       <a href="gfrepi_c.html">gfrepi_c</a>,   <a href="gfrepu_c.html">gfrepu_c</a>,     <a href="gfrepf_c.html">gfrepf_c</a>, 
                       bail,       <a href="gfbail_c.html">gfbail_c</a>,     &amp;cnfine,   
                       &amp;result                              );


            if ( <a href="gfbail_c.html">gfbail_c</a>() ) 
            {
               /.
               Clear the CSPICE interrupt indication. This is
               an essential step for programs that continue
               running after an interrupt; <a href="gfbail_c.html">gfbail_c</a> will
               continue to return SPICETRUE until this step
               has been performed.
               ./
               <a href="gfclrh_c.html">gfclrh_c</a>();


               /.
               We've trapped an interrupt signal. In a realistic
               application, the program would continue operation
               from this point. In this simple example, we simply
               display a message and quit.
               ./
               printf ( &quot;\nSearch was interrupted.\n\nThis message &quot;
                        &quot;was written after an interrupt signal\n&quot;
                        &quot;was trapped. By default, the program &quot;
                        &quot;would have terminated \nbefore this message &quot;
                        &quot;could be written.\n\n&quot;                       );
            }
            else
            {

               if ( <a href="wncard_c.html">wncard_c</a>(&amp;result) == 0 ) 
               {
                  printf ( &quot;No occultation was found.\n&quot; );
               }
               else
               {
                  for ( i = 0;  i &lt; <a href="wncard_c.html">wncard_c</a>(&amp;result);  i++ )
                  {
                     /.
                     fetch and display each occultation interval.
                     ./
                     <a href="wnfetd_c.html">wnfetd_c</a> ( &amp;result, i, &amp;left, &amp;right );

                     <a href="timout_c.html">timout_c</a> ( left,  TIMFMT, TIMLEN, begstr );
                     <a href="timout_c.html">timout_c</a> ( right, TIMFMT, TIMLEN, endstr );

                     printf ( &quot;Interval %d\n&quot;, (int)i );
                     printf ( &quot;   Start time: %s\n&quot;, begstr );
                     printf ( &quot;   Stop time:  %s\n&quot;, endstr );
                  }
               }

            }

            return ( 0 );
         }
 
      When this program was executed on a PC/Linux/gcc platform, the
      progress report had the format shown below:

         Occultation/transit search   6.02% done.

      The completion percentage was updated approximately once per
      second.

      When this program completed execution, the output was:
 

         Occultation/transit search 100.00% done.

         interval 0
            start time: 2001 DEC 14 20:10:14.195952  (TDB)
            stop time:  2001 DEC 14 21:35:50.317994  (TDB)


      When the program was interrupted at an arbitrary time, 
      the output was:

         Occultation/transit search  13.63% done.
         Search was interrupted.

         This message was written after an interrupt signal
         was trapped. By default, the program would have terminated
         before this message could be written.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   1) If the caller passes in the default, constant step  
      size routine, <a href="gfstep_c.html">gfstep_c</a>, the caller must set the step 
      size by calling the entry point <a href="gfsstp_c.html">gfsstp_c</a> before 
      calling <b>gfocce_c</b>. The call syntax for <a href="gfsstp_c.html">gfsstp_c</a> is 
 
         <a href="gfsstp_c.html">gfsstp_c</a> ( step );
 
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman   (JPL) 
   L.S. Elson     (JPL) 
   W.L. Taber     (JPL) 
   I.M. Underwood (JPL) 
   E.D. Wright    (JPL) 
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 2.0.0, 29-FEB-2016 (NJB) (EDW)

      Edit to example program to use &quot;%d&quot; with explicit casts
      to int for printing SpiceInts with printf.

      Updated to support use of DSKs.

   -CSPICE Version 1.0.0, 15-APR-2009 (NJB) (LSE) (WLT) (IMU) (EDW)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   GF mid-level occultation search
</PRE>
<h4>Link to routine gfocce_c source file <a href='../../../src/cspice/gfocce_c.c'>gfocce_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:54:35 2017</pre>

</body>
</html>


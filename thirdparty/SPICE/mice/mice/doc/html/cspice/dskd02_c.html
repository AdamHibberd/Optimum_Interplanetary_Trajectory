
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>dskd02_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>dskd02_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void dskd02_c ( SpiceInt               handle,
                   ConstSpiceDLADescr   * dladsc,
                   SpiceInt               item,
                   SpiceInt               start,
                   SpiceInt               room,
                   SpiceInt             * n,
                   SpiceDouble          * values ) 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Fetch double precision data from a type 2 DSK segment. 
 </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/das.html">DAS</a> 
   <a href="../req/dsk.html">DSK</a> 
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   DAS 
   DSK 
   FILES 
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   Variable  I/O  Description 
   --------  ---  -------------------------------------------------- 
   handle     I   DSK file handle. 
   dladsc     I   DLA descriptor. 
   item       I   Keyword identifying item to fetch. 
   start      I   Start index. 
   room       I   Amount of room in output array. 
   n          O   Number of values returned. 
   values     O   Array containing requested item. 
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
   handle         is the handle of a DSK file containing a type 2 
                  segment from which data are to be fetched. 
 
   dladsc         is the DLA descriptor associated with the segment 
                  from which data are to be fetched. 
 
   item           is an integer &quot;keyword&quot; parameter designating the
                  double precision data item to fetch.
 
                  Names, meanings, and value of keyword parameters
                  supported by this routine are given in the header
                  file

                     SpiceDSK.h
 
                  The keyword parameters for double precision data
                  listed there are supported by this routine.
 
   start          is the start index within specified data item from
                  which data are to be fetched.  The index of the first
                  element of each data item is 0. This convention
                  applies uniformly to all data, even if the data are
                  associated with a set of 1-based indices.  For
                  example, the vertex ID range starts at 1 (this fact
                  is language-independent), but a caller would use a
                  `start' value of 0 to fetch the first vertex.
 
   room           is the amount of room in the output array.  It is
                  permissible to provide an output array that has too
                  little room to fetch an item in one call.
 
 </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
   n              is the number of elements fetched to the output 
                  array `values'. `n' is normally in the range  
                  1:room; if an error occurs on the call, `n' is 
                  undefined. 
 
   values         is a contiguous set of elements of the item 
                  designated by `item'. The correspondence of  
                  `values' with the elements of the data item is: 
 
                     values[0]      item[start] 
                       ...             ... 
                     values[n-1]    item[start+n-1]
                   
                  If an error occurs on the call, `values' is  
                  undefined. 
 </PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   See the header files  
 
      SpiceDLA.h 
      SpiceDSK.h 
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
   1) If the input handle is invalid, the error will be diagnosed by 
      routines in the call tree of this routine.  
 
   2) If a file read error occurs, the error will be diagnosed by 
      routines in the call tree of this routine. 
 
   3) If the input DLA descriptor is invalid, the effect of this 
      routine is undefined. The error *may* be diagnosed by routines 
      in the call tree of this routine, but there are no 
      guarantees. 
 
   4) If `room' is non-positive, the error SPICE(VALUEOUTOFRANGE) 
      is signaled. 
 
   5) If the coarse voxel scale read from the designated segment 
      is less than 1, the error PICE(VALUEOUTOFRANGE) is signaled. 
 
   6) If the input keyword parameter is not recognized, the error 
      SPICE(NOTSUPPORTED) is signaled. 
 
   7) If `start' is less than 0 or greater than or equal to the size of
      the item to be fetched, the error SPICE(INDEXOUTOFRANGE) is
      signaled.
 </PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   See input argument `handle'. 
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   Most SPICE applications will not need to call this routine. The
   routines <a href="dskv02_c.html">dskv02_c</a>, <a href="dskp02_c.html">dskp02_c</a>, and <a href="dskz02_c.html">dskz02_c</a> provide a higher-level
   interface for fetching DSK type 2 vertex and plate data.

   DSK files are built using the DLA low-level format and 
   the DAS architecture; DLA files are a specialized type of DAS 
   file in which data are organized as a doubly linked list of 
   segments.  Each segment's data belong to contiguous components of 
   character, double precision, and integer type. 

   Note that the DSK descriptor for the segment is not needed by this
   routine; the DLA descriptor contains the base address and size
   information for the integer, double precision, and character
   components of the segment, and these suffice for the purpose of
   fetching data.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 

   The numerical results shown for this example may differ across
   platforms. The results depend on the SPICE kernels used as
   input, the compiler and supporting libraries, and the machine
   specific arithmetic implementation.


   1) Look up all the vertices associated with each plate 
      of the model contained in a specified type 2 segment. 
      For this example, we'll show the context of this look-up: 
      opening the DSK file for read access, traversing a trivial, 
      one-segment list to obtain the segment of interest. 


   Example code begins here.


         #include &lt;stdio.h&gt;
         #include &quot;SpiceUsr.h&quot;
         #include &quot;SpiceDLA.h&quot;
         #include &quot;SpiceDSK.h&quot;

         int main()
         {

            /.
            Local parameters
            ./
            #define FILSIZ          256 

            /.
            Local variables
            ./
            SpiceBoolean            found;

            SpiceChar               dsk     [ FILSIZ ];

            SpiceDLADescr           dladsc;

            SpiceDouble             vrtces  [3][3];

            SpiceInt                handle;
            SpiceInt                i;
            SpiceInt                j;
            SpiceInt                n;
            SpiceInt                np;
            SpiceInt                start;
            SpiceInt                vrtids  [3];


            /. 
            Prompt for the name of the DSK to read.
            ./
            <a href="prompt_c.html">prompt_c</a> ( &quot;Enter DSK name &gt; &quot;, FILSIZ, dsk );

            /.
            Open the DSK file for read access. We use the DAS-level
            interface for this function.
            ./
            <a href="dasopr_c.html">dasopr_c</a> ( dsk, &amp;handle );

            /.
            Begin a forward search through the kernel, treating the
            file as a DLA. In this example, it's a very short search.
            ./
            <a href="dlabfs_c.html">dlabfs_c</a> ( handle, &amp;dladsc, &amp;found );

            if ( !found  )
            {
               /.
               We arrive here only if the kernel
               contains no segments.  This is
               unexpected, but we're prepared for it.
               ./
               <a href="setmsg_c.html">setmsg_c</a> ( &quot;No segments found in DSK file #.&quot; );
               <a href="errch_c.html">errch_c</a>  ( &quot;#&quot;, dsk                           );
               <a href="sigerr_c.html">sigerr_c</a> ( &quot;SPICE(NODATA)&quot;                    );
            }

            /.
            If we made it this far, `dladsc' is the
            DLA descriptor of the first segment.

            Find the number of plates in the model.
            ./    
            <a href="dski02_c.html">dski02_c</a> ( handle, &amp;dladsc, SPICE_DSK02_KWNP, 
                       0,      1,       &amp;n,             &amp;np );

            /.
            For each plate, look up the desired data.
            ./
            for ( i = 1;  i &lt;= np;  i++ )
            {
               /.
               For the Ith plate, find the associated
               vertex IDs.  We must take into account
               the fact that each plate has three
               vertices when we compute the start
               index.     
               ./
               start = 3*(i-1);

               <a href="dski02_c.html">dski02_c</a> ( handle, &amp;dladsc, SPICE_DSK02_KWPLAT, start,  
                          3,      &amp;n,      vrtids                   );

               for ( j = 0;  j &lt; 3;  j++  )
               {
                  /.
                  Fetch the vertex associated with
                  the jth vertex ID.  Again, each
                  vertex is a 3-vector.  Note that
                  the vertices are double-precision
                  data, so we fetch them using
                  <b>dskd02_c</b>.          
                  ./
                  start = (vrtids[j]-1)*3;

                  <b>dskd02_c</b> ( handle, &amp;dladsc, SPICE_DSK02_KWVERT, start,  
                             3,      &amp;n,      vrtces[j]               );
               }

               /.
               Display the vertices of the ith plate:
               ./
               printf ( &quot;\n&quot;
                        &quot;Plate number:  %d\n&quot;
                        &quot;   Vertex 1: ( %+e   %+e   %+e )\n&quot;
                        &quot;   Vertex 2: ( %+e   %+e   %+e )\n&quot;
                        &quot;   Vertex 3: ( %+e   %+e   %+e )\n&quot;,
                        (int)i,
                        vrtces[0][0], vrtces[0][1], vrtces[0][2], 
                        vrtces[1][0], vrtces[1][1], vrtces[1][2], 
                        vrtces[2][0], vrtces[2][1], vrtces[2][2]  );
            }

            /.
            Close the kernel.  This isn't necessary in a stand-
            alone program, but it's good practice in subroutines
            because it frees program and system resources.
            ./
            <a href="dascls_c.html">dascls_c</a> ( handle );

            return ( 0 );
         }


   When this program was run on a PC/Linux/gcc/64-bit platform,
   using a DSK file containing data representing a regular
   icosahedron, the output was:


      Plate number:  1
         Vertex 1: ( +0.000000e+00   +0.000000e+00   +1.175570e+00 )
         Vertex 2: ( +1.051460e+00   +0.000000e+00   +5.257310e-01 )
         Vertex 3: ( +3.249200e-01   +1.000000e+00   +5.257310e-01 )

      Plate number:  2
         Vertex 1: ( +0.000000e+00   +0.000000e+00   +1.175570e+00 )
         Vertex 2: ( +3.249200e-01   +1.000000e+00   +5.257310e-01 )
         Vertex 3: ( -8.506510e-01   +6.180340e-01   +5.257310e-01 )

         ...

      Plate number:  20
         Vertex 1: ( +8.506510e-01   -6.180340e-01   -5.257310e-01 )
         Vertex 2: ( +0.000000e+00   +0.000000e+00   -1.175570e+00 )
         Vertex 3: ( +8.506510e-01   +6.180340e-01   -5.257310e-01 )
 
 </PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
   1) The underlying f2c'd routine

         dskd02_ 

      called by this routine uses discovery check-in to boost execution
      speed.  However, that routine is in violation of NAIF standards
      for use of discovery check-in:  routines called from that routine
      may signal errors.  If errors are signaled in routines called
      from dskd02_, that routine's name will be missing from the
      traceback message.
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman    (JPL) 
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 1.0.0, 04-APR-2017 (NJB)

      Updated parameter references in example program.
      Removed unnecessary include statements.
      Updated header.

      DSKLIB_C Version 1.0.0, 12-FEB-2010 (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   fetch d.p. data from a type 2 dsk segment 
 </PRE>
<h4>Link to routine dskd02_c source file <a href='../../../src/cspice/dskd02_c.c'>dskd02_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Wed Apr  5 17:54:32 2017</pre>

</body>
</html>

